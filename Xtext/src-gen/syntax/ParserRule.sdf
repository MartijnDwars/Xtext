
module ParserRule
imports Common

exports
  context-free start-symbols
    AbstractRule

  context-free syntax
    "="                                        -> Operator                       {cons("Assignment")}
    "+="                                       -> Operator                       {cons("AddAssignment")}
    "?="                                       -> Operator                       {cons("BooleanAssignment")}
    AbstractMetaModelReference? ID             -> TypeRef                        {cons("TypeRef")}
    STRING "::"                                -> AbstractMetaModelReference     {cons("AbstractMetaModelReference")}
    ID Returns? ":" Alternatives ";"           -> AbstractRule                   {cons("ParserRule")}
    "returns" TypeRef                          -> Returns                        {cons("Returns")}
    {UnorderedGroup "|"}+                      -> Alternatives                   {cons("Alternatives")}
    {Group "&"}+                               -> UnorderedGroup                 {cons("UnorderedGroup")}
    AbstractToken+                             -> Group                          {cons("Group")}
    AbstractTokenWithCardinality               -> AbstractToken                  {cons("AbstractTokenWithCardinality")}
    Action                                     -> AbstractToken                  {cons("Action")}
    Assignment Cardinality?                    -> AbstractTokenWithCardinality   {cons("Assignment")}
    AbstractTerminal Cardinality?              -> AbstractTokenWithCardinality   {cons("AbstractTerminal")}
    Predicated? ID Operator AssignableTerminal -> Assignment                     {cons("Assignment")}
    "=>"                                       -> Predicated                     {cons("Predicated")}
    "->"                                       -> Predicated                     {cons("FirstSetPredicated")}
    STRING                                     -> AssignableTerminal             {cons("Keyword")}
    RuleCall                                   -> AssignableTerminal             {cons("RuleCall")}
    ParenthesizedAssignableElement             -> AssignableTerminal             {cons("ParenthesizedAssignableElement")}
    "[" TypeRef "]"                            -> AssignableTerminal             {cons("CrossReference")}
    ID                                         -> RuleCall                       {cons("RuleCall")}
    "(" AssignableAlternatives ")"             -> ParenthesizedAssignableElement {cons("ParenthesizedAssignableElement")}
    {AssignableTerminal "|"}+                  -> AssignableAlternatives         {cons("AssignableAlternatives")}
    "{" TypeRef ActionCurrent? "}"             -> Action                         {cons("Action")}
    "." ID Operator "current"                  -> ActionCurrent                  {cons("ActionCurrent")}
    STRING                                     -> AbstractTerminal               {cons("Keyword")}
    ParenthesizedElement                       -> AbstractTerminal               {cons("ParenthesizedElement")}
    RuleCall                                   -> AbstractTerminal               {cons("RuleCall")}
    Predicated STRING                          -> AbstractTerminal               {cons("PredicatedKeyword")}
    Predicated RuleCall                        -> AbstractTerminal               {cons("PredicatedRuleCall")}
    Predicated "(" Alternatives ")"            -> AbstractTerminal               {cons("PredicatedGroup")}
    "(" Alternatives ")"                       -> ParenthesizedElement           {cons("ParenthesizedElement")}

  context-free syntax
    CONTENTCOMPLETE -> AbstractMetaModelReference     {cons("COMPLETION-AbstractMetaModelReference")}
    CONTENTCOMPLETE -> AbstractRule                   {cons("COMPLETION-AbstractRule")}
    CONTENTCOMPLETE -> Returns                        {cons("COMPLETION-Returns")}
    CONTENTCOMPLETE -> Alternatives                   {cons("COMPLETION-Alternatives")}
    CONTENTCOMPLETE -> UnorderedGroup                 {cons("COMPLETION-UnorderedGroup")}
    CONTENTCOMPLETE -> Assignment                     {cons("COMPLETION-Assignment")}
    CONTENTCOMPLETE -> AssignableTerminal             {cons("COMPLETION-AssignableTerminal")}
    CONTENTCOMPLETE -> ParenthesizedAssignableElement {cons("COMPLETION-ParenthesizedAssignableElement")}
    CONTENTCOMPLETE -> AssignableAlternatives         {cons("COMPLETION-AssignableAlternatives")}
    CONTENTCOMPLETE -> Action                         {cons("COMPLETION-Action")}
    CONTENTCOMPLETE -> ActionCurrent                  {cons("COMPLETION-ActionCurrent")}
    CONTENTCOMPLETE -> AbstractTerminal               {cons("COMPLETION-AbstractTerminal")}
    CONTENTCOMPLETE -> ParenthesizedElement           {cons("COMPLETION-ParenthesizedElement")}