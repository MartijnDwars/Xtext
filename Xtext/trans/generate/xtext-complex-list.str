module xtext-complex-list

imports
	
	include/Xtext
	include/TemplateLang
	generate/parser-rule

rules
	is-complex-list :
		input -> <not(equal(input))> <find-consecutive-elements(find-list-initiator, find-list-tail)> input
	
	replace-complex-list :
		input -> <try(find-consecutive-elements(find-list-initiator, find-list-tail))> input
		
	find-consecutive-elements(filter1, filter2):
		[head | [head_tail | tail]] -> <flatten-list> out
	where
		<not(equal([]))> head_tail;
		out := <if(a := <filter1> head, 
					if(b := <filter2> (head_tail, a),
							<id> [b | tail], 
							<id> [head | <try(find-consecutive-elements(filter1, filter2))> [head_tail | tail]]
					),
					<id> [head | <try(find-consecutive-elements(filter1, filter2))> [head_tail | tail]]
				)>
	
	find-list-initiator:
		AssignmentAbstractToken(_, a, _, b, None()) -> (a, b)
	
	find-list-tail:
		(AbstractTerminalAbstractToken(
                    Alternatives(
                      [ UnorderedGroup(
                          [ Group(
                              [ AbstractTerminalAbstractToken(sep, None())
                              , AssignmentAbstractToken(None(), a, AddAssignment(), b, None())
                              ])
                          ])
                      ])
                  , Some(Any())
                  ),
		(a, b)) -> IterSep(Label(Unquoted(a), b), sep) 
		
	find-list-tail:
		(AbstractTerminalAbstractToken(
                    Alternatives(
                      [ UnorderedGroup(
                          [ Group(
                              [ AbstractTerminalAbstractToken(sep, None())
                              , AbstractTerminalAbstractToken(b, None())
                              ])
                          ])
                      ])
                  , Some(Any())
                  ),
		(a, b)) -> IterSep(Label(Unquoted(a), b), sep)