module terminal-rule

imports
	
	include/Xtext
	include/TemplateLang
	generate/common

rules

	list-to-conc:
		[singleton] -> singleton
	
	list-to-conc:
		[head | tail] -> Conc(head, <list-to-conc> tail)
	
	gen-rule:
		TerminalRule(Returns(terminal-name, _), terminal-token-element) ->
			LexicalSyntax([SdfProduction(SortDef(terminal-name), Rhs([<gen-terminal-token-element ; innermost(post-process-terminal-rule)> terminal-token-element]), NoAttrs())])
	
	post-process-terminal-rule:
		CharClass(Simple(Present(Alt(x, y)))) -> Alt(x, y)
	
	gen-terminal-alternative:
		TerminalGroup(terminal-group) -> gen-terminal-group
		where
			gen-terminal-group := <map(gen-terminal-group) ; list-to-sequence> terminal-group
	
	list-to-sequence:
		[singleton] -> singleton
	
	list-to-sequence:
		[h|t] -> Sequence(h, t)
	
	gen-terminal-group:
		TerminalToken(terminal-token-element, cardinality-opt) -> <gen-cardinality(|<gen-terminal-token-element> terminal-token-element)> cardinality-opt
	
	gen-terminal-token-element:
		TerminalAlternatives(terminal-alternatives) -> Parenthetical(<map(gen-terminal-alternative) ; list-to-alt> terminal-alternatives)
	
	// Turn [a, b, c, ...] into Alt(a, Alt(b, Alt(c, ...)))
	list-to-alt:
		[singleton] -> singleton
	
	list-to-alt:
		[head | tail] -> Alt(head, <list-to-alt> tail)
	
	gen-terminal-token-element:
		Keyword(s) -> Lit(<single-quote> s)
	
	gen-terminal-token-element:
		CharacterRange(Keyword(x), Keyword(y)) -> CharClass(Simple(Present(Range(Short(x), Short(y)))))
	
	gen-terminal-token-element:
		RuleCall(reference) -> <fail>
		where
			<debug> "TODO"
		
	gen-terminal-token-element:
		NegatedToken(terminal-token-element) -> Comp(<gen-terminal-token-element> terminal-token-element)
	
	gen-terminal-token-element:
		Wildcard(_) -> CharClass(Comp(Simple(Absent())))