module generate/common

imports
	
	include/Xtext
	include/TemplateLang

rules 

	id-to-name:
		ID -> Unparameterized(name)
		where
			name := <last> ID
	
	remove-sortdef:
		SortDef(name) -> name
			
	// Cardinality
	
	gen-cardinality(|abstract-terminal):
		None() -> abstract-terminal
	
	gen-cardinality(|abstract-terminal):
		Some(Any()) -> IterStar(abstract-terminal)
	
	gen-cardinality(|abstract-terminal):
		Some(Multiple()) -> Iter(abstract-terminal)
		
	gen-cardinality(|abstract-terminal):
		Some(Optional()) -> Opt(abstract-terminal)
	
	//Permutations (Unordered-Groups)
	/*
		Might replace this by a more functional variant:
			
			-- | The 'permutations' function returns the list of all permutations of the argument.
			--
			-- > permutations "abc" == ["abc","bac","cba","bca","cab","acb"]
				 permutations            :: [a] -> [[a]]
				 permutations xs0        =  xs0 : perms xs0 []
                 where
    			 	perms []     _  = []
    				perms (t:ts) is = foldr interleave (perms ts (t:is)) (permutations is)
      				where interleave    xs     r = let (_,zs) = interleave' id xs r in zs
            			interleave' _ []     r = (ts, r)
            			interleave' f (y:ys) r = let (us,zs) = interleave' (f . (y:)) ys r
                                     			 in  (y:us, f (t:y:us) : zs)
	
	*/
	
	// The only permutation of a singleton list is a list containing that element 
	permutations:
		[x] -> [[x]]
	
	// do "permutations(|xs) x" for every x in xs
	permutations:
		xs -> <map(permutations(|xs)) ; concat> xs
	
	// Remove argument from xs, compute permutations of resulting list
	permutations(|xs):
		x -> <filter(not(?x)) ; permutations ; map(prepend(|x))> xs
	
	// Prepend x to every list of xs. E.g. prepend(1, [[2, 3], [3, 2]]) = [[1, 2, 3], [1, 3, 2]]
	prepend-list:
		(x, xss) -> <map(prepend(|x))> xss
	
	// Prepend x to the given list
	prepend(|x) = ?t ; ![x | t]
	
	// Usage:
	//
	// test-prepend:
	//  	_ -> <prepend-list> (2, [[2, 3], [11, 111]])
	// 
	test-permutations:
		_ -> <permutations> [1, 2, 3]
	
	
	

	
	gen-permutations(|perm-set):
		_ -> permutations
		where
			permutations := <recursive-permutations(|perm-set, perm-set, <length> perm-set)>
			
	recursive-permutations(|set, block, n):
		_ -> <if(<eq> (1,n), <filter-permutations(|block)> set, recursive-permutations(|new_set, block, <dec> n))>
		where
			new_set := <list-combinations> [set, block]
			
	filter-permutations(|block):
		set -> filtered-permutations
		where
			filtered-list := <collect-all(filter(|block))> set;
			filtered-permutations := <map(TupleToList; last)> filtered-list
	
	filter(|block):
		set -> <set-eq> (block, set)

  /**
   * Append an element to the tail of the list
   * 
   * @type (List(a), a) -> List(a)
   */
  append:
    (list, e) -> <reverse> [e | <reverse> list]
  
rules // Pattern match left- and right associative ParserRules
  
  is-left-assoc = is-simple-left-assoc + is-nested-left-assoc
  
  is-simple-left-assoc:
    ParserRule(name, _, _, Alternatives([UnorderedGroup([Group(tokens)])])) -> <true>
  where
    <is-left-assoc-tokens> tokens
  
  is-nested-left-assoc:
    ParserRule(name, _, _, Alternatives([
      UnorderedGroup([
        Group([
          AbstractTerminalAbstractToken(
            Alternatives([
              UnorderedGroup([
                Group(tokens)
              ])
            ]),
            Some(Optional())
          )
        ])
      ])
    ])) -> <true>
  where
    debug;
    <debug> 5;
    <is-left-assoc-tokens> tokens
  
  is-left-assoc-tokens:
    tokens -> <true>
  where
    // "<first> tokens" is a RuleCall or a Keyword (we're more liberal here)
    !tokens; ?[AbstractTerminalAbstractToken(_, None()) | _];
    
    // "<last> tokens > group" has cardinality any
    <last> tokens; ?AbstractTerminalAbstractToken(Alternatives([UnorderedGroup([Group(sub-tokens)])]), Some(Any()));

    // "<last> tokens > group" starts with an action which assigns 'current'
    !sub-tokens; ?[ActionAbstractToken(Action(TypeRef(None(), _), Some(ActionCurrent(_, Assignment())))) | _];
    
    // "<last> tokens > group" ends with an action which assigns 'current'
    <last> sub-tokens; ?AssignmentAbstractToken(None(), _, Assignment(), RuleCall(_), None())
  
  is-right-assoc:
    ParserRule(name, _, _, Alternatives([UnorderedGroup([Group(tokens)])])) -> <true>
  where
    // "<last> tokens" has cardinality Optional
    <last> tokens; ?AbstractTerminalAbstractToken(Alternatives([UnorderedGroup([Group(sub-tokens)])]), Some(Optional()));
    
    // "<last> tokens > group" starts with action with same name as rule
    !sub-tokens; ?[h | _]; !h; ?ActionAbstractToken(Action(TypeRef(None(), name), Some(ActionCurrent(_, Assignment()))));
    
    // "<last> tokens > group" ends with assignment with rulecall to same as name
    <last> sub-tokens; ?AssignmentAbstractToken(None(), _, Assignment(), RuleCall(name), None())
