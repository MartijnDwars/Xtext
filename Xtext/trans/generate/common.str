module generate/common

imports
	
	include/Xtext
	include/TemplateLang

rules 

	id-to-name:
		ID -> Unparameterized(name)
		where
			name := <last> ID
	
	remove-sortdef:
		SortDef(name) -> name
	
	remove-parenthetical:
		//Parenthetical(content) -> content
		content -> content
		where
			<debug> content
			
	// Cardinality
	
	gen-cardinality(|abstract-terminal):
		None() -> abstract-terminal
	
	gen-cardinality(|abstract-terminal):
		Some(Any()) -> IterStar(abstract-terminal)
	
	gen-cardinality(|abstract-terminal):
		Some(Multiple()) -> Iter(abstract-terminal)
		
	gen-cardinality(|abstract-terminal):
		Some(Optional()) -> Opt(abstract-terminal)
	
	//Permutations (Unordered-Groups)
	/*
		Might replace this by a more functional variant:
			
			-- | The 'permutations' function returns the list of all permutations of the argument.
			--
			-- > permutations "abc" == ["abc","bac","cba","bca","cab","acb"]
				 permutations            :: [a] -> [[a]]
				 permutations xs0        =  xs0 : perms xs0 []
                 where
    			 	perms []     _  = []
    				perms (t:ts) is = foldr interleave (perms ts (t:is)) (permutations is)
      				where interleave    xs     r = let (_,zs) = interleave' id xs r in zs
            			interleave' _ []     r = (ts, r)
            			interleave' f (y:ys) r = let (us,zs) = interleave' (f . (y:)) ys r
                                     			 in  (y:us, f (t:y:us) : zs)
	
	*/
	
	// The only permutation of a singleton list is a list containing that element 
	permutations:
		[x] -> [[x]]
	
	// do "permutations(|xs) x" for every x in xs
	permutations:
		xs -> <map(permutations(|xs)) ; concat> xs
	
	// Remove argument from xs, compute permutations of resulting list
	permutations(|xs):
		x -> <filter(not(?x)) ; permutations ; map(prepend(|x))> xs
	
	// Prepend x to every list of xs. E.g. prepend(1, [[2, 3], [3, 2]]) = [[1, 2, 3], [1, 3, 2]]
	prepend-list:
		(x, xss) -> <map(prepend(|x))> xss
	
	// Prepend x to the given list
	prepend(|x) = ?t ; ![x | t]
	
	// Usage:
	//
	// test-prepend:
	//  	_ -> <prepend-list> (2, [[2, 3], [11, 111]])
	// 
	test-permutations:
		_ -> <permutations> [1, 2, 3]
	
	
	

	
	gen-permutations(|perm-set):
		_ -> permutations
		where
			permutations := <recursive-permutations(|perm-set, perm-set, <length> perm-set)>
			
	recursive-permutations(|set, block, n):
		_ -> <if(<eq> (1,n), <filter-permutations(|block)> set, recursive-permutations(|new_set, block, <dec> n))>
		where
			new_set := <list-combinations> [set, block]
			
	filter-permutations(|block):
		set -> filtered-permutations
		where
			filtered-list := <collect-all(filter(|block))> set;
			filtered-permutations := <map(TupleToList; last)> filtered-list
	
	filter(|block):
		set -> <set-eq> (block, set)		
