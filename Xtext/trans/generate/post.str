module post

imports
	
	include/TemplateLang

rules
		
  /**
   * Group SdfProductions inside ContextFreeSyntax respectively
   * LexicalSyntax together.
   */
  post:
    Module(x, y, sdf-sections) -> Module(x, y, [
      SDFSection(ContextFreeStartSymbols(start-symbols)),	
      SDFSection(ContextFreeSyntax(cfs-productions)),
      SDFSection(LexicalSyntax(lex-productions))
    ])
    with
      cfs* := <collect(?ContextFreeSyntax(_))> sdf-sections;
      cfs-productions := <collect(?SdfProduction(_, _, _)+?SdfProductionWithCons(_,_,_))> cfs*;

      lex* := <collect(?LexicalSyntax(_))> sdf-sections;
      lex-productions := <collect(?SdfProduction(_, _, _))> lex*;
      
      start* := <collect(?ContextFreeStartSymbols(_))> sdf-sections;
      start-symbols := <collect(?Sort(_))> start*

  post:
    ContextFreeSyntax(productions) -> ContextFreeSyntax(<map(try(transform)); try(flatten-list)> productions)
  
  /**
   * Turn
   *   Expression.Plus = {Expression "+"}+ {left}
   * into
   *   Expression.Plus = Expression "+" Expression {left}
   */
  transform:
    x@SdfProductionWithCons(
      SortCons(SortDef(rule-name), cons)
    , Rhs([rhs])
    , attrs
    )
    ->
    [SdfProductionWithCons(
      SortCons(SortDef(rule-name), cons)
    , Rhs([Sort(rule-name), separator, Sort(rule-name)])
    , attrs
    )]
  where
  	!rhs; ?IterSep(Sort(rule-name), separator)
  
  /**
   * Turn
   *   Expression.Plus = {Expression "+"}+ {left}
   * into
   *   Expression.Plus = Expression "+" Expression {left}
   */
  transform:
    x@SdfProductionWithCons(
      SortCons(SortDef(rule-name), cons)
    , Rhs([rhs])
    , attrs
    )
    ->
    [SdfProductionWithCons(
      SortCons(SortDef(rule-name), cons)
    , Rhs([Sort(rule-name), separator, Sort(rule-name)])
    , attrs
    ), SdfProductionWithCons(
      SortCons(SortDef(rule-name), cons)
    , Rhs([])
    , NoAttrs()
    )]
  where
    !rhs; ?IterStarSep(Sort(rule-name), separator)
