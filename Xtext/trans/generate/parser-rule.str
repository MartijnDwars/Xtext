module parser-rule

imports
	
	libstratego-gpp
	lib/runtime/editor/interop
	lib/runtime/tmpl/pp
	include/TemplateLang
	sdf/src-gen/pp/TemplateLang-pp
	sdf/src-gen/pp/modules/Modules-pp
	include/Xtext
	generate/common
	generate/generate
	generate/terminal-rule

rules 
	
// 	sdf-pp = (prettyprint-sdf-Module + prettyprint-sdf-Grammar + prettyprint-Section); !V([], <id>); box2text-string(|120)
// 	
// 	gen-sdf-file:
// 		(selected, position, ast, path, project-path) -> (filename, <sdf-pp> <gen-sdf-debug> selected)
// 		where
// 			filename := $[[<remove-extension> path].sdf3]
// 	
// 	gen-sdf:
// 		(selected, position, ast, path, project-path) -> (filename, <gen-sdf-debug> selected)
// 		where
// 			filename := $[[<remove-extension> path].sdf3.aterm]
// 	
// 	gen-sdf-debug:
// 		selected -> <gen-grammar + gen-rule + gen-abstract-token> selected
// 	
// 	gen-sdf-debug:
// 		selected -> <map(gen-sdf-debug)> selected
// 		where
// 			<is-list> selected
// 	
// 	gen-grammar:
// 		Grammar(GrammarID(names), mixin, _, _, abstract-rules) -> Module(name,imports,sdf-sections)
// 		//$[module [name] [gen-mixin] context-free syntax [gen-abstract-rules]]
// 		where
// 			name               := <id-to-name> names;
// 			imports			   := <gen-imports> mixin;
// 			sdf-sections	   := <map(gen-rule)> abstract-rules
// 			//gen-mixin		   := <gen-imports> mixin;
// 			//gen-abstract-rules := <map(gen-rule) ; separate-by(|"\n")> abstract-rules
// 		
// 	gen-imports:
// 		None() -> []
// 		
// 	gen-imports:
// 		Some(Mixin(imports)) -> [Imports(<map(gen-import-name)> imports)]
// 		//$[imports [<map(gen-import-name) ; separate-by(|"\n")> imports]]
// 		
// 	gen-import-name:
// 		GrammarID(names) -> Module(name)
// 		where
// 			name			:= <id-to-name> names
// 
// 	gen-rule:
// 		ParserRule(name, _,_, alternatives) -> SDFSection(ContextFreeSyntax(alts))
// 		where
// 			alts			:= <gen-alternatives(|SortDef(name), NoAttrs())> alternatives
// 		
// 	gen-alternatives(|name, attr):
// 		Alternatives(unordered-groups) -> <flatten-list> <map(gen-unordered-groups(|name, attr))> unordered-groups
// 			
// 	gen-unordered-groups(|name, attr):
// 		UnorderedGroup(groups) -> <flatten-list> [group | extra_rules]
// 		where
// 			permutations     := <gen-permutations(|groups)>;
// 			groups_generated := <map(gen-groups(|name, attr))> permutations;
// 			group            := <try(concat)> <map(extract-outputs)> groups_generated;
// 			extra_rules      := <try(concat)> <map(extract-nested-outputs)> groups_generated
// 				
// 	gen-groups(|name, attr):
// 		groups -> (SdfProduction(name, Rhs(rule), attr), extra_rules)
// 		where
// 			rules_generated := <map(gen-group-content(|name, attr))> groups;
// 			rule			:= <try(concat)> <map(extract-outputs)> rules_generated;
// 			extra_rules		:= <try(concat)> <map(extract-nested-outputs)> rules_generated			
// 	
// 	gen-group-content(|name, attr):
// 		Group(content) -> (output, nested_outputs)
// 		with
// 			content_generated := <map(gen-abstract-token(|name, attr))> content;
// 			output := <try(concat)> <map(extract-outputs)> content_generated;
// 			nested_outputs := <try(concat)> <map(extract-nested-outputs)> content_generated
// 			
// 	extract-outputs:
// 		(output, nested_output) -> output
// 		
// 	extract-nested-outputs:
// 		(output, nested_output) -> nested_output
// 
// 
// 			
// 	// 	where
// 	//		output := <if(is-double-quoted, gen-dq-word, gen-sq-word)> word
// 	// 		
// 	// gen-dq-word:
// 	// 	input -> (Lit(<double-quote> input),[])
// 	// 	
// 	// gen-sq-word:
// 	// 	input -> (CiLit(<double-quote> input),[])
// 		
// 	gen-abstract-token(|name, attr):
// 		AssignmentAbstractToken(_, feature, type, assignable-terminal, cardinality-opt) -> (rule, nested_output)
// 		where
// 			(output, nested_output) := <gen-assignable-terminal(|name, attr)> assignable-terminal;
// 			gen-cardinality := <gen-cardinality(|output)> cardinality-opt;
// 			rule := Label(Unquoted(feature), gen-cardinality)
// 		
// 	gen-assignable-terminal(|name, attr):
// 		RuleCall(input) -> (Sort(input),[])
// 		
// 	gen-assignable-terminal(|name, attr):
// 		Keyword(word) -> (Lit(<double-quote> word),[])
// 		// where
// 		// 	output := <if(is-double-quoted, gen-dq-word, gen-sq-word)> word
// 	
// 	gen-assignable-terminal(|name, attr):
// 		CrossReference(TypeRef(_, _), None()) -> (Sort("ID"), [])
// 		
// 	gen-assignable-terminal(|name, attr):
// 		CrossReference(TypeRef(_, _), Some(CrossReferenceableTerminal(RuleCall(terminal-rule)))) -> (Sort(terminal-rule), [])
// 	
// 	gen-assignable-terminal(|name, attr):
// 		AssignableAlternatives(alternatives) -> (output, nested)
// 		where
// 			name_string := <remove-sortdef> name;
// 			new_name := <newname> <conc-strings> (name_string, "-");
// 			output := Sort(new_name);
// 			nested := <try(concat)> <map(gen-abstract-alternative(|SortDef(new_name), attr))> alternatives
// 	
// 	gen-abstract-alternative(|name, attr):
// 		input -> [SdfProduction(name, Rhs([rule]), attr) | extra_rules]
// 		where
// 			(rule, nested) := <gen-assignable-terminal(|name, attr)> input;		
// 			extra_rules		:= <try(concat)> nested
// 		
// //Deprecated
// 
// 	//gen-rule:
// 		//ParserRule(name, _, _, alternatives) -> gen-alternatives
// 		//where
// 			//gen-alternatives := <gen-alternatives(|name)> alternatives
// 
// //	gen-alternatives(|name):
// 	//	Alternatives(unordered-groups) -> $[[<map(gen-unordered-group ; add-name(|name)) ; separate-by(|"\n")> unordered-groups]]
// 	
// 	//add-name(|name):
// 		//unordered-group -> $[[name] = [unordered-group]]
// 	
// 	//gen-unordered-group:
// 		//UnorderedGroup(groups) -> $[[<map(gen-group) ; separate-by(|"\n")> groups]]
// 		
// 	//gen-group:
// 		//Group(abstract-tokens) -> $[<[<map(gen-abstract-token) ; separate-by(|" ")> abstract-tokens]>]
// 		
// 	// gen-abstract-token:
// 	// 	AssignmentAbstractToken(_, feature, AddAssignment(), assignable-terminal, cardinality-opt) -> $[<{ [gen-assignable-terminal] " " } [gen-cardinality]>]
// 	// 	with
// 	// 		gen-assignable-terminal := <gen-assignable-terminal> assignable-terminal;
// 	// 		gen-cardinality			:= <gen-cardinality> cardinality-opt
// 	
// //	gen-abstract-token:
// 	//	AbstractTerminalAbstractToken(abstract-terminal, cardinality-opt) -> $[[gen-abstract-terminal] [gen-cardinality]]
// 	//	with
// 	//		gen-abstract-terminal := <gen-abstract-terminal> abstract-terminal;
// 	//		gen-cardinality       := <gen-cardinality-opt> cardinality-opt
// 	
// 	gen-abstract-token:
// 		ActionAbstractToken(_) -> $[]
// 	
// 	//gen-abstract-terminal:
// 		//Keyword(ID) -> $[[ID]]
// 		
// 	//gen-abstract-terminal:
// 		//RuleCall(ID) -> $[[ID]]
// 
// 	//gen-abstract-terminal:
// 	 //	x@Alternatives(_) -> <gen-internal-alternatives> x
// 	
// //	gen-internal-alternatives:
// 	//	Alternatives(unordered-groups) -> $[[<map(gen-unordered-group) ; separate-by(|"\n")> unordered-groups]]
// 	
// 	//gen-assignable-terminal:
// 		//RuleCall(ID) -> $[<[ID]>]
// 	
// 	//gen-assignable-terminal:
// 	//	AssignableAlternatives(assignable-terminal) -> $[] //<map(gen-assignable-terminal)> assignable-terminal
// 	
// 	/*	
// 	Fixed, don't change
// 	*/
// 	

	
	gen-grammar:
		Grammar(GrammarID(names), mixin, _, _, abstract-rules) -> Module(name,imports,sdf-sections)
		where
			name               := <id-to-name> names;
			imports			   := <gen-imports> mixin;
			sdf-sections	   := <map(gen-rule)> abstract-rules
		
	gen-imports:
		None() -> []
		
	gen-imports:
		Some(Mixin(imports)) -> [Imports(<map(gen-import-name)> imports)]
		
	gen-import-name:
		GrammarID(names) -> Module(name)
		where
			name			:= <id-to-name> names

	gen-rule:
		p@ParserRule(name, _,_, alternatives) -> SDFSection(ContextFreeSyntax(alts-with-assoc))
		where
			alts := <gen-alternatives(|SortDef(name), NoAttrs())> alternatives
		; if <is-left-assoc> p then
		    alts-with-assoc := <add-associativity(|Left())> alts
		  else if <is-right-assoc> p then
	      alts-with-assoc := <add-associativity(|Right())> alts
	    else
	      alts-with-assoc := alts
	    end end
	
	add-associativity(|associativity):
	  productions -> <map(try(add-associativity(|associativity)))> productions
	where
		<debug> productions
  ; <is-list> productions
	
	add-associativity(|associativity):
	  SdfProductionWithCons(cons, rhs, NoAttrs()) -> SdfProductionWithCons(cons, rhs, Attrs([Assoc(associativity)]))
	
	//Here the mess starts
	
	gen-alternatives(|name, attr):
		//Input: Alternative with listof unorderedgroups
		//Output: List of Contextfree rules
		Alternatives(unordered-groups) -> <flatten-list> <map(gen-unordered-group(|name, attr, 1))> unordered-groups
			
	gen-unordered-group(|name, attr, main):
		//Input: UnorderedGroup with list of groups
		//Convert input to its final form
		//If necessary create permutations
		//Output: One or more permutations of the rules formed by the groups
		UnorderedGroup(groups) -> output
		where
			output := <if(<equal(|1)> <length> groups, <singular-group-constructor(|name, attr, main)> groups, <perm-group-constructor(|name, attr)> groups)>
		
	perm-group-constructor(|name, attr):
		input -> <flatten-list>[rule_set | extra_rules]
		where
			rules_generated := <map(gen-group-content(|name, attr))> input;
			rule := <map(extract-outputs)> rules_generated;
			permutations := <map(flatten-list)> <gen-permutations(|rule)>;
			rule_set := <map(group-constructor(|name, attr))> permutations;
			extra_rules		:= <try(concat)> <map(extract-nested-outputs)> rules_generated
	
	gen-group-content(|name, attr):
		Group(content) -> (rule, extra_rules)
		where
			rules_generated := <map(gen-abstract-token-rule(|name, attr))> content;
			rule			:= <try(concat)> <map(extract-outputs)> rules_generated;
			extra_rules		:= <try(concat)> <map(extract-nested-outputs)> rules_generated

	group-constructor(|name, attr):
		input -> SdfProductionWithCons(SortCons(name, Constructor(new_constructor)), Rhs(input), attr)
		where
			new_constructor := <newname> <conc-strings>(<remove-sortdef> name, "-Perm-")
			
	singular-group-constructor(|name, attr, main):
		//If any of the contents is of type assignment or action, then return a constructor name
		[Group(content)] -> rule
		where
			constructor := <collect-one(is-action) + collect-one(is-assignment) + id> content;
			output := <if(or(<equal(|content)> constructor, <equal(|0)> main) , <gen-sortdef-rule(|name, attr)> content, <gen-sortconstructordef-rule(|name, attr, constructor)> content)>;
			rule := <flatten-list> [<try(concat)> <(extract-outputs)> output| <try(concat)> <(extract-nested-outputs)> output]
	
	contains(|t)= oncetd(?t)

	
	gen-sortdef-rule(|name, attr):
		//input: [List of AbstractTokens]
		//output: SdfProduction with no constructor + nested rules
		input -> (SdfProduction(name, Rhs(rule), attr), extra_rules)
		where
			rules_generated := <map(gen-abstract-token-rule(|name, attr))> input;
			rule			:= <try(concat)> <map(extract-outputs)> rules_generated;
			extra_rules		:= <try(concat)> <map(extract-nested-outputs)> rules_generated
			
	gen-sortconstructordef-rule(|name, attr, constructor):
		input -> (SdfProductionWithCons(SortCons(name, Constructor(new_constructor)), Rhs(rule), attr), extra_rules)
		where
			new_constructor := <if(<equal(|constructor)> "AssignmentToken", <newname> <conc-strings> (<remove-sortdef> name, "-"), <id> constructor)>;
			rules_generated := <map(gen-abstract-token-rule(|name, attr))> input;
			rule			:= <try(concat)> <map(extract-outputs)> rules_generated;
			extra_rules		:= <try(concat)> <map(extract-nested-outputs)> rules_generated		
		
	gen-abstract-token-rule(|name, attr):
		AssignmentAbstractToken(_, feature, type, assignable-terminal, cardinality-opt) -> (rule, nested_output)
		where
			(output, nested_output) := <gen-assignable-terminal(|name, attr, cardinality-opt)> assignable-terminal;
			gen-cardinality := <gen-cardinality(|output)> cardinality-opt;
			rule := Label(Quoted(<double-quote> feature), gen-cardinality)
	
	extract-action-ID:
		Action(TypeRef(_, name), _) -> name
		
	extract-outputs:
		(output, nested_output) -> output
		
	extract-nested-outputs:
		(output, nested_output) -> nested_output
	
	is-action:
		ActionAbstractToken(action) -> output
		where
			output := <extract-action-ID> action
	/*		
	is-action:
		AbstractTerminalAbstractToken(Alternatives([UnorderedGroup([Group(content)])]), _) -> output
		where
			output := <fetch-elem(is-action)> content
	*/
		
	is-assignment:
		AssignmentAbstractToken(_, _, _, _, _) -> "AssignmentToken"
	
	/*	
	is-assignment:
		AbstractTerminalAbstractToken(Alternatives([UnorderedGroup([Group(content)])]), _) -> output
		where
			output := <fetch-elem(is-assignment)> content
	*/	
	
	
	gen-abstract-terminal(|name, attr, cardinality-opt):
		Alternatives(unordered-groups) -> (output,nested)
		where
			name_string := <remove-sortdef> name;
			new_name := <newname> <conc-strings> (name_string, "-SubRule-");
			//new_name := <newname> "SubRule-";
			output := Sort(new_name);
			nested := <try(concat)> <map(gen-unordered-group(|SortDef(new_name), attr, 0))> unordered-groups
			
	/* Revised Sections */
	gen-abstract-token-rule(|name, attr):
		AbstractTerminalAbstractToken(abstract-terminal, cardinality-opt) -> (gen-cardinality, <flatten-list> nested_output)
		with
			(output, nested_output) := <gen-abstract-terminal(|name, attr, cardinality-opt)> abstract-terminal;
			gen-cardinality       := <gen-cardinality(|output)> cardinality-opt


		

	
	

			
			
			
			
	gen-assignable-terminal(|name, attr, cardinality-opt):
		RuleCall(input) -> (Sort(input),[])
		
	gen-assignable-terminal(|name, attr, cardinality-opt):
		Keyword(word) -> output
		where
			output := <if(<equal(|None())> cardinality-opt, <gen-keyword-wo-cardinality(|name, attr)> Keyword(word), <gen-keyword-w-cardinality(|name, attr)> Keyword(word))>
			
	gen-assignable-terminal(|name, attr, cardinality-opt):
		CrossReference(TypeRef(_, _), None()) -> (Sort("ID"), [])
		
	gen-assignable-terminal(|name, attr, cardinality-opt):
		CrossReference(TypeRef(_, _), Some(CrossReferenceableTerminal(RuleCall(terminal-rule)))) -> (Sort(terminal-rule), [])
	
	gen-assignable-terminal(|name, attr, cardinality-opt):
		AssignableAlternatives(alternatives) -> (output, nested)
		where
			name_string := <remove-sortdef> name;
			new_name := <newname> <conc-strings> (name_string, "-SubRule-");
			//new_name := <newname> "SubRule-";
			output := Sort(new_name);
			nested := <try(concat)> <map(gen-abstract-alternative(|SortDef(new_name), attr,cardinality-opt))> alternatives
			
		gen-abstract-alternative(|name, attr, cardinality-opt):
		input -> [SdfProduction(name, Rhs([rule]), attr) | extra_rules]
		where
			(rule, nested) := <gen-assignable-terminal(|name, attr, cardinality-opt)> input;		
			extra_rules		:= <try(concat)> nested

	//Need to fix the look of this, currently introduces extra space in final program 
	gen-abstract-token-rule(|name, attr):
 		ActionAbstractToken(_) -> (Lit(""),[])

 			
 			
 			
 			
 			
 			
 			
 			
 			
 			
 			
 			
 			
 			
 			
 			
 			
 	/* Abstract Terminal Rulecall */
	gen-abstract-terminal(|name, attr, cardinality-opt):
		RuleCall(input) -> (Sort(input),[])
	
	/* Abstract Terminal Keyword */
	gen-abstract-terminal(|name, attr, cardinality-opt):
		Keyword(word) -> output
		where
			output := <if(<equal(|None())> cardinality-opt, <gen-keyword-wo-cardinality(|name, attr)> Keyword(word), <gen-keyword-w-cardinality(|name, attr)> Keyword(word))>
			
	gen-keyword-wo-cardinality(|name, attr):
		Keyword(word) -> (<gen-quoted-word> word, [])
		
	gen-keyword-w-cardinality(|name, attr):
		Keyword(word) -> (Sort(rulename),[subrule])
		where
			rulename := <newname> "Keyword-";
			subrule := SdfProduction(SortDef(rulename), Rhs([<gen-quoted-word> word]), attr)
  
  gen-quoted-word:
    word -> Lit(<double-quote> <try(un-single-quote + un-double-quote)> word)

