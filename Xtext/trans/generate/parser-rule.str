module parser-rule

imports
	
	libstratego-gpp
	lib/runtime/editor/interop
	lib/runtime/tmpl/pp
	include/TemplateLang
	sdf/src-gen/pp/TemplateLang-pp
	sdf/src-gen/pp/modules/Modules-pp
	include/Xtext
	generate/common
	generate/generate
	generate/terminal-rule

rules 
	
	gen-grammar:
		Grammar(GrammarID(names), mixin, _, _, abstract-rules) -> Module(name,imports,sdf-sections)
		where
			name               := <id-to-name> names;
			imports			   := <gen-imports> mixin;
			start-symbol	   := <fetch-elem(gen-start-symbol)> abstract-rules;
			sdf-sections	   := [start-symbol | <map(gen-rule)> abstract-rules]
		
	gen-imports:
		None() -> []
		
	gen-imports:
		Some(Mixin(imports)) -> [Imports(<map(gen-import-name)> imports)]
		
	gen-import-name:
		GrammarID(names) -> Module(name)
		where
			name			:= <id-to-name> names

	gen-start-symbol:
		ParserRule(name, _, _, _) -> SDFSection(ContextFreeStartSymbols([Sort(name)]))

	gen-rule:
		p@ParserRule(name, _,_, alternatives) -> SDFSection(ContextFreeSyntax(alts-with-assoc))
		where
			alts := <gen-alternatives(|SortDef(name), NoAttrs())> alternatives
		; if <is-left-assoc> p then
		    alts-with-assoc := <add-associativity(|Left())> alts
		  else if <is-right-assoc> p then
	      alts-with-assoc := <add-associativity(|Right())> alts
	    else
	      alts-with-assoc := alts
	    end end
	
	add-associativity(|associativity):
	  productions -> <map(try(add-associativity(|associativity)))> productions
	where
		<debug> productions
  ; <is-list> productions
	
	add-associativity(|associativity):
	  SdfProductionWithCons(cons, rhs, NoAttrs()) -> SdfProductionWithCons(cons, rhs, Attrs([Assoc(associativity)]))
	
	gen-alternatives(|name, attr):
		//Input: Alternative with listof unorderedgroups
		//Output: List of Contextfree rules
		Alternatives(unordered-groups) -> <flatten-list> <map(gen-unordered-group(|name, attr, 1))> unordered-groups
			
	gen-unordered-group(|name, attr, main):
		//Input: UnorderedGroup with list of groups
		//Convert input to its final form
		//If necessary create permutations
		//Output: One or more permutations of the rules formed by the groups
		UnorderedGroup(groups) -> output
		where
			output := <if(?[_], singular-group-constructor(|name, attr, main), perm-group-constructor(|name, attr))> groups
		
	perm-group-constructor(|name, attr):
		input -> <flatten-list>[rule_set | extra_rules]
		where
			rules_generated := <map(gen-group-content(|name, attr))> input;
			rule := <map(extract-outputs)> rules_generated;
			permutations := <map(flatten-list)> <gen-permutations(|rule)>;
			rule_set := <map(group-constructor(|name, attr))> permutations;
			extra_rules		:= <try(concat)> <map(extract-nested-outputs)> rules_generated
	
	gen-group-content(|name, attr):
		Group(content) -> (rule, extra_rules)
		where
			rules_generated := <map(gen-abstract-token-rule(|name, attr))> content;
			rule			:= <try(concat)> <map(extract-outputs)> rules_generated;
			extra_rules		:= <try(concat)> <map(extract-nested-outputs)> rules_generated

	group-constructor(|name, attr):
		input -> SdfProductionWithCons(SortCons(name, Constructor(new_constructor)), Rhs(input), attr)
		where
			new_constructor := <newname> <conc-strings>(<remove-sortdef> name, "-Perm-")
			
	singular-group-constructor(|name, attr, main):
		//If any of the contents is of type assignment or action, then return a constructor name
		[Group(content)] -> rule
		where
			constructor := <collect-one(is-action) + collect-one(is-assignment) + id> content;
			output := <if(or(<equal(|content)> constructor, <equal(|0)> main) , <gen-sortdef-rule(|name, attr)> content, <gen-sortconstructordef-rule(|name, attr, constructor)> content)>;
			rule := <flatten-list> [<try(concat)> <(extract-outputs)> output| <try(concat)> <(extract-nested-outputs)> output]
	


	gen-sortdef-rule(|name, attr):
		//input: [List of AbstractTokens]
		//output: SdfProduction with no constructor + nested rules
		input -> (SdfProduction(name, Rhs(rule), attr), extra_rules)
		where
			rules_generated := <map(gen-abstract-token-rule(|name, attr))> input;
			rule			:= <try(concat)> <map(extract-outputs)> rules_generated;
			extra_rules		:= <try(concat)> <map(extract-nested-outputs)> rules_generated
			
	gen-sortconstructordef-rule(|name, attr, constructor):
		input -> (SdfProductionWithCons(SortCons(name, Constructor(new_constructor)), Rhs(rule), attr), extra_rules)
		where
			new_constructor := <if(<equal(|constructor)> "AssignmentToken", <newname> <conc-strings> (<remove-sortdef> name, "-"), <id> constructor)>;
			rules_generated := <map(gen-abstract-token-rule(|name, attr))> input;
			rule			:= <try(concat)> <map(extract-outputs)> rules_generated;
			extra_rules		:= <try(concat)> <map(extract-nested-outputs)> rules_generated		
		
	gen-abstract-token-rule(|name, attr):
		AssignmentAbstractToken(_, feature, type, assignable-terminal, cardinality-opt) -> (rule, nested_output)
		where
			(output, nested_output) := <gen-assignable-terminal(|name, attr, cardinality-opt)> assignable-terminal;
			gen-cardinality := <gen-cardinality(|output)> cardinality-opt;
			rule := Label(Quoted(<double-quote> feature), gen-cardinality)
	
	extract-action-ID:
		Action(TypeRef(_, name), _) -> name
		
	extract-outputs:
		(output, nested_output) -> output
		
	extract-nested-outputs:
		(output, nested_output) -> nested_output
	
	is-action:
		ActionAbstractToken(action) -> output
		where
			output := <extract-action-ID> action
		
	is-assignment:
		AssignmentAbstractToken(_, _, _, _, _) -> "AssignmentToken"
	
	
	gen-abstract-terminal(|name, attr, cardinality-opt):
		Alternatives(unordered-groups) -> (output,nested)
		where
			name_string := <remove-sortdef> name;
			new_name := <newname> <conc-strings> (name_string, "-SubRule-");
			output := Sort(new_name);
			nested := <try(concat)> <map(gen-unordered-group(|SortDef(new_name), attr, 0))> unordered-groups
			
	/* Revised Sections */
	gen-abstract-token-rule(|name, attr):
		AbstractTerminalAbstractToken(abstract-terminal, cardinality-opt) -> (gen-cardinality, <flatten-list> nested_output)
		with
			(output, nested_output) := <gen-abstract-terminal(|name, attr, cardinality-opt)> abstract-terminal;
			gen-cardinality       := <gen-cardinality(|output)> cardinality-opt

	gen-assignable-terminal(|name, attr, cardinality-opt):
		RuleCall(input) -> (Sort(input),[])
		
	gen-assignable-terminal(|name, attr, cardinality-opt):
		Keyword(word) -> output
		where
			output := <if(<equal(|None())> cardinality-opt, <gen-keyword-wo-cardinality(|name, attr)> Keyword(word), <gen-keyword-w-cardinality(|name, attr)> Keyword(word))>
			
	gen-assignable-terminal(|name, attr, cardinality-opt):
		CrossReference(TypeRef(_, _), None()) -> (Sort("ID"), [])
		
	gen-assignable-terminal(|name, attr, cardinality-opt):
		CrossReference(TypeRef(_, _), Some(CrossReferenceableTerminal(RuleCall(terminal-rule)))) -> (Sort(new_name), [])
		where
			new_name := <conc-strings> (terminal-rule, "_Ref")
	
	gen-assignable-terminal(|name, attr, cardinality-opt):
		AssignableAlternatives(alternatives) -> (output, nested)
		where
			name_string := <remove-sortdef> name;
			new_name := <newname> <conc-strings> (name_string, "-SubRule-");
			//new_name := <newname> "SubRule-";
			output := Sort(new_name);
			nested := <try(concat)> <map(gen-abstract-alternative(|SortDef(new_name), attr,cardinality-opt))> alternatives
			
		gen-abstract-alternative(|name, attr, cardinality-opt):
		input -> [SdfProduction(name, Rhs([rule]), attr) | extra_rules]
		where
			(rule, nested) := <gen-assignable-terminal(|name, attr, cardinality-opt)> input;		
			extra_rules		:= <try(concat)> nested

	//Need to fix the look of this, currently introduces extra space in final program 
	gen-abstract-token-rule(|name, attr):
 		ActionAbstractToken(_) -> ("",[])

 	/* Abstract Terminal Rulecall */
	gen-abstract-terminal(|name, attr, cardinality-opt):
		RuleCall(input) -> (Sort(input),[])
	
	/* Abstract Terminal Keyword */
	gen-abstract-terminal(|name, attr, cardinality-opt):
		Keyword(word) -> output
		where
			output := <if(<equal(|None())> cardinality-opt, <gen-keyword-wo-cardinality(|name, attr)> Keyword(word), <gen-keyword-w-cardinality(|name, attr)> Keyword(word))>
			
	gen-keyword-wo-cardinality(|name, attr):
		Keyword(word) -> (<gen-quoted-word> word, [])
		
	gen-keyword-w-cardinality(|name, attr):
		Keyword(word) -> (Sort(rulename),[subrule])
		where
			rulename := <newname> "Keyword-";
			subrule := SdfProduction(SortDef(rulename), Rhs([<gen-quoted-word> word]), attr)
  
  gen-quoted-word:
    word -> Lit(<double-quote> <try(un-single-quote + un-double-quote)> word)

