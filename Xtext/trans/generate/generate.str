module generate

imports
	
	libstratego-gpp
	lib/runtime/editor/interop
	lib/runtime/tmpl/pp
	include/TemplateLang
	sdf/src-gen/pp/TemplateLang-pp
	sdf/src-gen/pp/modules/Modules-pp
	include/Xtext
	generate/common
	generate/terminal-rule
	include/TemplateLang

rules 
	
	sdf-pp = (prettyprint-sdf-Module + prettyprint-sdf-Grammar + prettyprint-Section); !V([], <id>); box2text-string(|120)
	
	gen-sdf-file:
		(selected, position, ast, path, project-path) -> (filename, <sdf-pp> <gen-sdf-debug> selected)
		where
			filename := $[[<remove-extension> path].sdf3]
	
	gen-sdf:
		(selected, position, ast, path, project-path) -> (filename, <gen-sdf-debug> selected)
		where
			filename := $[[<remove-extension> path].sdf3.aterm]
	
	gen-sdf-debug:
		selected -> <gen-grammar + gen-rule + gen-abstract-token> selected
	
	gen-sdf-debug:
		selected -> <map(gen-sdf-debug)> selected
		where
			<is-list> selected
	
	gen-grammar:
		Grammar(GrammarID(names), mixin, _, _, abstract-rules) -> Module(name,imports,sdf-sections)
		//$[module [name] [gen-mixin] context-free syntax [gen-abstract-rules]]
		where
			name               := <id-to-name> names;
			imports			   := <gen-imports> mixin;
			sdf-sections	   := <map(gen-rule)> abstract-rules
			//gen-mixin		   := <gen-imports> mixin;
			//gen-abstract-rules := <map(gen-rule) ; separate-by(|"\n")> abstract-rules
		
	gen-imports:
		None() -> []
		
	gen-imports:
		Some(Mixin(imports)) -> [Imports(<map(gen-import-name)> imports)]
		//$[imports [<map(gen-import-name) ; separate-by(|"\n")> imports]]
		
	gen-import-name:
		GrammarID(names) -> Module(name)
		where
			name			:= <id-to-name> names

	gen-rule:
		ParserRule(name, _,_, alternatives) -> SDFSection(ContextFreeSyntax(alts))
		where
			alts			:= <gen-alternatives(|SortDef(name), NoAttrs())> alternatives
		
	gen-alternatives(|name, attr):
		Alternatives(unordered-groups) -> <flatten-list> <map(gen-unordered-groups(|name, attr))> unordered-groups
			
	gen-unordered-groups(|name, attr):
		UnorderedGroup(groups) -> <flatten-list> [group | extra_rules]
		where
			permutations     := <gen-permutations(|groups)>;
			groups_generated := <map(gen-groups(|name, attr))> permutations;
			group            := <try(concat)> <map(extract-outputs)> groups_generated;
			extra_rules      := <try(concat)> <map(extract-nested-outputs)> groups_generated
				
	gen-groups(|name, attr):
		groups -> (SdfProduction(name, Rhs(rule), attr), extra_rules)
		where
			rules_generated := <map(gen-group-content(|name, attr))> groups;
			rule			:= <try(concat)> <map(extract-outputs)> rules_generated;
			extra_rules		:= <try(concat)> <map(extract-nested-outputs)> rules_generated			
	
	gen-group-content(|name, attr):
		Group(content) -> (output, nested_outputs)
		with
			content_generated := <map(gen-abstract-token(|name, attr))> content;
			output := <try(concat)> <map(extract-outputs)> content_generated;
			nested_outputs := <try(concat)> <map(extract-nested-outputs)> content_generated
			
	extract-outputs:
		(output, nested_output) -> output
		
	extract-nested-outputs:
		(output, nested_output) -> nested_output

	gen-abstract-token(|name, attr):
		AbstractTerminalAbstractToken(abstract-terminal, cardinality-opt) -> (gen-cardinality, <flatten-list> nested_output)
		with
			(output, nested_output) := <gen-abstract-terminal(|name, attr)> abstract-terminal;
			gen-cardinality       := <gen-cardinality(|output)> cardinality-opt

	gen-abstract-terminal(|name, attr):
		RuleCall(input) -> (Sort(input),[])
		
	gen-abstract-terminal(|name, attr):
		Alternatives(unordered-groups) -> (output,nested)
		where
			name_string := <remove-sortdef> name;
			new_name := <newname> <conc-strings> (name_string, "-");
			output := Sort(new_name);
			nested := <try(concat)> <map(gen-unordered-groups(|SortDef(new_name), attr))> unordered-groups
	
	gen-abstract-terminal(|name, attr):
		Keyword(word) -> (Lit(<double-quote> word),[])
	// 	where
	// 		output := <if(is-double-quoted, gen-dq-word, gen-sq-word)> word
	// 		
	// gen-dq-word:
	// 	input -> (Lit(<double-quote> input),[])
	// 	
	// gen-sq-word:
	// 	input -> (CiLit(<double-quote> input),[])
		
	gen-abstract-token(|name, attr):
		AssignmentAbstractToken(_, feature, type, assignable-terminal, cardinality-opt) -> (rule, nested_output)
		where
			(output, nested_output) := <gen-assignable-terminal(|name, attr)> assignable-terminal;
			gen-cardinality := <gen-cardinality(|output)> cardinality-opt;
			rule := Label(Unquoted(feature), gen-cardinality)
		
	gen-assignable-terminal(|name, attr):
		RuleCall(input) -> (Sort(input),[])
		
	gen-assignable-terminal(|name, attr):
		Keyword(word) -> (Lit(<double-quote> word),[])
		// where
		// 	output := <if(is-double-quoted, gen-dq-word, gen-sq-word)> word
	
	gen-assignable-terminal(|name, attr):
		CrossReference(TypeRef(_, _), None()) -> (Sort("ID"), [])
		
	gen-assignable-terminal(|name, attr):
		CrossReference(TypeRef(_, _), Some(CrossReferenceableTerminal(RuleCall(terminal-rule)))) -> (Sort(terminal-rule), [])
	
	gen-assignable-terminal(|name, attr):
		AssignableAlternatives(alternatives) -> (output, nested)
		where
			name_string := <remove-sortdef> name;
			new_name := <newname> <conc-strings> (name_string, "-");
			output := Sort(new_name);
			nested := <try(concat)> <map(gen-abstract-alternative(|SortDef(new_name), attr))> alternatives
	
	gen-abstract-alternative(|name, attr):
		input -> [SdfProduction(name, Rhs([rule]), attr) | extra_rules]
		where
			(rule, nested) := <gen-assignable-terminal(|name, attr)> input;		
			extra_rules		:= <try(concat)> nested
		
//Deprecated

	//gen-rule:
		//ParserRule(name, _, _, alternatives) -> gen-alternatives
		//where
			//gen-alternatives := <gen-alternatives(|name)> alternatives

//	gen-alternatives(|name):
	//	Alternatives(unordered-groups) -> $[[<map(gen-unordered-group ; add-name(|name)) ; separate-by(|"\n")> unordered-groups]]
	
	//add-name(|name):
		//unordered-group -> $[[name] = [unordered-group]]
	
	//gen-unordered-group:
		//UnorderedGroup(groups) -> $[[<map(gen-group) ; separate-by(|"\n")> groups]]
		
	//gen-group:
		//Group(abstract-tokens) -> $[<[<map(gen-abstract-token) ; separate-by(|" ")> abstract-tokens]>]
		
	// gen-abstract-token:
	// 	AssignmentAbstractToken(_, feature, AddAssignment(), assignable-terminal, cardinality-opt) -> $[<{ [gen-assignable-terminal] " " } [gen-cardinality]>]
	// 	with
	// 		gen-assignable-terminal := <gen-assignable-terminal> assignable-terminal;
	// 		gen-cardinality			:= <gen-cardinality> cardinality-opt
	
//	gen-abstract-token:
	//	AbstractTerminalAbstractToken(abstract-terminal, cardinality-opt) -> $[[gen-abstract-terminal] [gen-cardinality]]
	//	with
	//		gen-abstract-terminal := <gen-abstract-terminal> abstract-terminal;
	//		gen-cardinality       := <gen-cardinality-opt> cardinality-opt
	
	gen-abstract-token:
		ActionAbstractToken(_) -> $[]
	
	//gen-abstract-terminal:
		//Keyword(ID) -> $[[ID]]
		
	//gen-abstract-terminal:
		//RuleCall(ID) -> $[[ID]]

	//gen-abstract-terminal:
	 //	x@Alternatives(_) -> <gen-internal-alternatives> x
	
//	gen-internal-alternatives:
	//	Alternatives(unordered-groups) -> $[[<map(gen-unordered-group) ; separate-by(|"\n")> unordered-groups]]
	
	//gen-assignable-terminal:
		//RuleCall(ID) -> $[<[ID]>]
	
	//gen-assignable-terminal:
	//	AssignableAlternatives(assignable-terminal) -> $[] //<map(gen-assignable-terminal)> assignable-terminal
