module generate

imports
	
	libstratego-gpp
	lib/runtime/editor/interop
	lib/runtime/tmpl/pp
	include/TemplateLang
	sdf/src-gen/pp/TemplateLang-pp
	include/Xtext
	generate/common
	generate/terminal-rule

rules 

	sdf-pp = prettyprint-Grammar; !V([], <id>); box2text-string(|120)
	
	gen-sdf-file:
		(selected, position, ast, path, project-path) -> (filename, <sdf-pp> <gen-sdf-debug> selected)
		where
			filename := $[[<remove-extension> path].sdf3]
	
	gen-sdf:
		(selected, position, ast, path, project-path) -> (filename, <gen-sdf-debug> selected)
		where
			filename := $[[<remove-extension> path].sdf3]
	
	gen-sdf-debug:
		selected -> <gen-grammar + gen-rule + gen-abstract-token> selected
	
	gen-sdf-debug:
		selected -> <map(gen-sdf-debug)> selected
		where
			<is-list> selected
	
	gen-grammar:
		Grammar(GrammarID(names), _, _, _, abstract-rules) -> $[module [name]  [gen-abstract-rules]]
		where
			name               := <id-to-name> names;
			gen-abstract-rules := <map(gen-rule) ; separate-by(|"\n")> abstract-rules

	gen-rule:
		ParserRule(name, _, _, alternatives) -> gen-alternatives
		where
			gen-alternatives := <gen-alternatives(|name)> alternatives
	
	gen-alternatives(|name):
		Alternatives(unordered-groups) -> $[[<map(gen-unordered-group ; add-name(|name)) ; separate-by(|"\n")> unordered-groups]]
	
	add-name(|name):
		unordered-group -> $[[name] = [unordered-group]]
	
	gen-unordered-group:
		UnorderedGroup([Group(abstract-tokens)]) -> $[<[<map(gen-abstract-token) ; separate-by(|" ")> abstract-tokens]>]
	
	gen-abstract-token:
		AssignmentAbstractToken(_, feature, type, assignable-terminal, cardinality-opt) -> <gen-assignable-terminal> assignable-terminal
	
	gen-abstract-token:
		AbstractTerminalAbstractToken(abstract-terminal, cardinality-opt) -> $[[gen-abstract-terminal] [gen-cardinality]]
		with
			gen-abstract-terminal := <gen-abstract-terminal> abstract-terminal;
			gen-cardinality       := <gen-cardinality-opt> cardinality-opt
	
	gen-abstract-token:
		ActionAbstractToken(_) -> $[]
	
	gen-abstract-terminal:
		Keyword(ID) -> $[[ID]]
		
	gen-abstract-terminal:
		RuleCall(ID) -> $[[ID]]

	// gen-abstract-terminal:
	// 	x@Alternatives(_) -> <gen-alternatives> x
	
	gen-assignable-terminal:
		RuleCall(ID) -> $[<[ID]>]
	
	gen-assignable-terminal:
		AssignableAlternatives(assignable-terminal) -> $[] //<map(gen-assignable-terminal)> assignable-terminal
	
	// TODO: For now, just use the type. Eventually, this should be a reference (i.e. ID that is linked to `type`)
	gen-assignable-terminal:
		CrossReference(TypeRef(_, type)) -> $[<[type]>]